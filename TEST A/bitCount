int bitCount(int x)
{
int mask_1 = 0x55 | (0x55 << 8);       // 01010101 01010101
    mask_1 = mask_1 | (mask_1 << 16);     // 01010101 01010101 01010101 01010101
    int mask_2 = 0x33 | (0x33 << 8);       // 00110011 00110011
    mask_2 = mask_2 | (mask_2 << 16);     // 00110011 00110011 00110011 00110011
    int mask_4 = 0x0F | (0x0F << 8);       // 00001111 00001111
    mask_4 = mask_4 | (mask_4 << 16);     // 00001111 00001111 00001111 00001111
    int mask_8 = 0xFF | (0xFF << 16);       // 00000000 11111111 00000000 11111111
    int mask_16 = 0xFF | (0xFF << 8);      // 00000000 00000000 11111111 11111111
    x = (x & mask_1) + ((x >> 1) & mask_1); // 邻位相加构造位数为2的数字
    x = (x & mask_2) + ((x >> 2) & mask_2); // 位数为2的相邻数字相加构造位数为4的数字
    x = (x & mask_4) + ((x >> 4) & mask_4); // 位数为4的相邻数字相加构造位数为8的数字
    x = (x & mask_8) + ((x >> 8) & mask_8); // 位数为8的相邻数字相加构造位数为16的数字
    x = (x & mask_16) + ((x >> 16) & mask_16); // 位数16为的相邻数字相加构造位数为32的数字（这个时候原来的每一位的权重都变成了1）
    return x;
}
    
/*
对于一个8位二进制
mask1 = 01010101
mask2 = 00110011
mask3 =00001111;
x = x>>1 + x&mask1; 
x = x >>2 +x&mask2;
x = x>>4 + x&mask;
这个实际上就是相邻的数相加，产生新的数，再让相邻的数相加
如果是16位的数字就需要构造4个mask，
以此类推如果是32位就需要构造5个mask
*/
